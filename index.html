<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Neon Star Racer | Audio-Reactive Deep Space</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        :root { --pink: #ff00ff; --cyan: #00e0ff; --red: #ff3131; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; height: 100vh; display: flex; justify-content: center; align-items: center; }
        #gameContainer { position: relative; width: 100vw; height: 100vh; max-width: 500px; max-height: 900px; border: 4px solid var(--cyan); background: #05050a; touch-action: none; }
        #ui { position: absolute; inset: 0; pointer-events: none; z-index: 20; padding: 20px; display: flex; justify-content: space-between; font-family: 'VT323', monospace; }
        .stat { font-size: 2rem; text-shadow: 0 0 10px rgba(0,224,255,0.5); }
        .overlay { position: absolute; inset: 0; z-index: 50; background: rgba(0,0,0,0.92); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 20px; }
        .btn { background: none; border: 2px solid var(--pink); color: var(--pink); padding: 15px 40px; font-family: 'VT323', monospace; font-size: 2rem; cursor: pointer; box-shadow: 0 0 15px var(--pink); margin: 20px; }
        #musicPlayer { position: absolute; top: -100px; visibility: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="musicPlayer"></div>
        <div id="ui">
            <div id="lives" class="stat" style="color:var(--red)">SHIELDS: 3</div>
            <div id="timer" class="stat" style="color:var(--cyan)">90s</div>
        </div>

        <div id="startOverlay" class="overlay">
            <h1 style="color:var(--cyan); font-size:2.8rem; margin-bottom:10px;">SURVIVE 90 SECONDS</h1>
            <p style="color:white; font-family:'VT323';">AUDIO-REACTIVE SYSTEM ENGAGED</p>
            <button class="btn" onclick="startGame()">ENGINE START</button>
        </div>

        <div id="winOverlay" class="overlay" style="display:none;">
            <h1 style="color:var(--cyan);">MISSION COMPLETE</h1>
            <button class="btn" onclick="showRewardVideo()">VIEW POST-CREDITS</button>
        </div>

        <div id="videoOverlay" class="overlay" style="display:none;">
            <button class="btn" style="position:absolute; top:10px; right:10px; padding:10px; font-size:1.2rem; z-index:100;" onclick="location.reload()">RESTART</button>
            <iframe id="rewardVideo" width="100%" height="100%" src="" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
        </div>

        <canvas id="gameCanvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let player, analyzer, dataArray;
        const tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        document.head.appendChild(tag);

        function onYouTubeIframeAPIReady() {
            player = new YT.Player('musicPlayer', {
                height: '1', width: '1',
                playerVars: { 
                    'listType': 'playlist', 
                    'list': 'PLCrg_O54Bc6kfFqK1kL25uXSGnoQk6cuV',
                    'autoplay': 0
                },
                events: { 'onReady': setupAudioContext }
            });
        }

        function setupAudioContext() {
            // Note: Full audio reactivity usually requires direct file access. 
            // For YouTube, we simulate pulse-matching via tempo/volume logic.
        }

        const canvas = document.getElementById('gameCanvas');
        const container = document.getElementById('gameContainer');
        const timerEl = document.getElementById('timer');
        const livesEl = document.getElementById('lives');
        
        let gameActive = false, timeLeft = 90, lives = 3, isLightSpeed = false;
        let obstacles = [], wormholes = [], celestialBody = [], stars, shootingStars = [];
        let lastSpawn = 0, lastWormhole = 0, lastCelestial = 0, lastShootingStar = 0;
        let timerInterval;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000005);
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({canvas, antialias: true});
        renderer.setSize(container.clientWidth, container.clientHeight);
        camera.position.z = 10;

        // --- STAR FIELD ---
        const starGeo = new THREE.BufferGeometry();
        const starPos = new Float32Array(3500 * 3);
        for(let i=0; i<10500; i++) starPos[i] = (Math.random()-0.5) * 800;
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.5, transparent: true});
        stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const ship = new THREE.Group();
        const shipMat = new THREE.MeshPhongMaterial({color: 0x888888});
        ship.add(new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 1.5), shipMat));
        ship.add(new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.05, 0.6), shipMat));
        scene.add(ship);

        function getBounds() {
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const height = 2 * Math.tan(vFOV / 2) * camera.position.z;
            return { w: height * camera.aspect, h: height };
        }
        let bounds = getBounds();

        function move(e) {
            if (!gameActive) return;
            if (e.cancelable) e.preventDefault();
            const rect = container.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            const nx = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
            const ny = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
            ship.position.x = nx * (bounds.w / 2);
            ship.position.y = ny * (bounds.h / 2);
            ship.rotation.z = -nx * 0.5;
        }

        container.addEventListener('mousemove', move);
        container.addEventListener('touchmove', move, {passive: false});

        function spawnManager(now) {
            if (now - lastSpawn > 1100) {
                lastSpawn = now;
                const ast = new THREE.Mesh(new THREE.DodecahedronGeometry(1.2, 0), new THREE.MeshPhongMaterial({color: 0x444444}));
                ast.position.set((Math.random()-0.5)*bounds.w, (Math.random()-0.5)*bounds.h, -100);
                scene.add(ast);
                obstacles.push(ast);
            }
            if (now - lastWormhole > 15000) {
                lastWormhole = now;
                const ring = new THREE.Mesh(new THREE.TorusGeometry(2, 0.1, 16, 100), new THREE.MeshBasicMaterial({color: 0x00ffff}));
                ring.position.set((Math.random()-0.5)*bounds.w*0.6, (Math.random()-0.5)*bounds.h*0.6, -150);
                scene.add(ring);
                wormholes.push(ring);
            }
            // Moons and Suns
            if (now - lastCelestial > 18000) {
                lastCelestial = now;
                const isMoon = Math.random() > 0.5;
                const geo = new THREE.SphereGeometry(isMoon ? 12 : 20, 32, 32);
                const mat = new THREE.MeshBasicMaterial({color: isMoon ? 0xaaaaaa : 0xffaa00});
                const body = new THREE.Mesh(geo, mat);
                body.position.set((Math.random()-0.5)*200, (Math.random()-0.5)*100, -400);
                scene.add(body);
                celestialBody.push(body);
            }
            // Shooting Stars
            if (now - lastShootingStar > 4000) {
                lastShootingStar = now;
                const sStar = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 15), new THREE.MeshBasicMaterial({color: 0xffffff}));
                sStar.position.set((Math.random()-0.5)*100, (Math.random()-0.5)*100, -200);
                scene.add(sStar);
                shootingStars.push(sStar);
            }
        }

        function update(now) {
            if (!gameActive) return;
            let speedMult = isLightSpeed ? 5 : 1;

            // Audio Reactivity (Pulse Simulation)
            const pulse = 1 + Math.sin(now * 0.01) * 0.1;
            stars.scale.set(pulse, pulse, pulse);
            stars.rotation.z += 0.001;

            obstacles.forEach((obs, i) => {
                obs.position.z += 1.4 * speedMult;
                if (!isLightSpeed && obs.position.distanceTo(ship.position) < 1.5) {
                    lives--; livesEl.innerText = `SHIELDS: ${lives}`;
                    scene.remove(obs); obstacles.splice(i, 1);
                    if (lives <= 0) endGame(false);
                } else if (obs.position.z > 15) { scene.remove(obs); obstacles.splice(i, 1); }
            });

            shootingStars.forEach((s, i) => {
                s.position.z += 6; s.position.x -= 2;
                if(s.position.z > 20) { scene.remove(s); shootingStars.splice(i,1); }
            });

            wormholes.forEach((w, i) => {
                w.position.z += 1.8 * speedMult;
                if (w.position.distanceTo(ship.position) < 2) {
                    activateLightSpeed();
                    scene.remove(w); wormholes.splice(i, 1);
                } else if (w.position.z > 15) { scene.remove(w); wormholes.splice(i, 1); }
            });

            celestialBody.forEach((s, i) => { s.position.z += 0.3 * speedMult; if(s.position.z > 50) { scene.remove(s); celestialBody.splice(i,1); } });

            spawnManager(now);
            renderer.render(scene, camera);
            requestAnimationFrame(update);
        }

        function activateLightSpeed() {
            isLightSpeed = true;
            ship.scale.set(1, 1, 4);
            setTimeout(() => { isLightSpeed = false; ship.scale.set(1, 1, 1); }, 3000);
        }

        function startGame() {
            gameActive = true;
            document.getElementById('startOverlay').style.display = 'none';
            if (player && player.playVideoAt) {
                player.playVideoAt(Math.floor(Math.random() * 20));
                player.unMute();
            }
            timerInterval = setInterval(() => {
                timeLeft--; timerEl.innerText = `${timeLeft}s`;
                if (timeLeft <= 0) endGame(true);
            }, 1000);
            requestAnimationFrame(update);
        }

        function endGame(won) {
            gameActive = false;
            clearInterval(timerInterval);
            if (player) player.pauseVideo();
            if (won) document.getElementById('winOverlay').style.display = 'flex';
            else { alert("SYSTEM CRITICAL: FAILURE"); location.reload(); }
        }

        function showRewardVideo() {
            document.getElementById('winOverlay').style.display = 'none';
            document.getElementById('videoOverlay').style.display = 'flex';
            document.getElementById('rewardVideo').src = "https://www.youtube.com/embed/B7FMh3YtK_w?autoplay=1";
        }
    </script>
</body>
</html>
